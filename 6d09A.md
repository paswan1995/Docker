##              Docker

## Docker container lifecycle

* Docker lifecycle states 
    * Created
    * Running
    * Paused
    * Stopped
    * Deleted
* ![preview](images/66.png)
* Accessing the applications inside docker containers
* From now the machine where we have installed docker will referred as host and the docker container will be referred as container
* We have access to host network & as of now containers are created in private container network, so to access applications inside containers we use port-forwording
* ![preview](images/67.png)

* __Port forwarding Command:__
* `docker conatiner run -d -p <host-port>:<container-port> <image>`

* Create a nginx container and expose on port 30000 
* `docker container run -d -p 3000:80 --name nginx1 nginx `

* ![preview](images)

* Create a jenkins container & expose 8080 port on 30001 port of host
* `docker container run -d -p 30001:8080 --name jenkis1 jenkins/jenkins`

* ![preview](images)

* To assing any random free port on host to container port
* `docker container run -d -p image`

* Lets create 3 nginx containers 
* `docker container run -d --name nginx1 -P nginx`
* `docker container run -d --name nginx2 -P nginx`
* `docker container run -d --name nginx3 -P nginx`
* ![preview](images)

## Exercise

* install docker on a linux vm
* `docker container run -d --name apache -P htppd`
* ![preview](images/68.png)
* Run 1 httpd containers (apache container) which runs on 80 port
* __`docker container inspect (container name/container id)` it will give you ip address of container__.
* ![preview](images/69.png)
* try accessing any application
* ![preview](images/70.png)
* stop the containers and try accessing
* ![preview](images/71.png) 
  __during stop condition container is not accessable__ 
* start the containers and access this should work
* __when you start the container after stoping its change the port no. , like before stop the container i have port no. `32768` after stop and again start its show its port no. `32769`__
* ![preview](images/72.png)
* pause the containers, access the application
* `docker container pause httpd`
* ![preview](images/73.png)
* ![preview](images/74.png)
* unpause the containers, access the application 
* __while pause and unpause container will not change its port no. its chnges only when you stop or start the container__
* ![preview](images/75.png)
* ![preview](images/76.png)
* delete the container 
* ![preview](images/77.png)
* `docker container rm -f httpd1`
* All used command's history
* ![preview](images/78.png) 
* __we have given 65000/65k free ports__
* __In docker when we use small p `-p` in that we have to give port no. but when we use capital P `-P` it will take automatically port no.__
* create a container of nginx or jenkins and give manually port no. and try to accessing on server 
* ![preview](images/80.png)
* ![preview](images/81.png)
* Nginx
* ![preview](images/82.png)
* Jenkins1
* ![preview](images/83.png)
* Jenkins using capital `-P` it takes automatically port no. or id.   
* ![preview](images/84.png)
* ![preview](images/85.png)

## Containerizing spring petclinic

* I have spring petclinic version 2.4.2 which requires java 11 and runs on port 8080 
* to start application `java -jar spring-petclinic-2.4.2.jar`
* What is required: 
   * openjdk-11-jdk
   * jar file 
* How to access application
   * http over port 8080

* Lets start the amazoncorretoo based container with port 8080 exposed
* refer: https://hub.docker.com/_/amazoncorretto
* `docker container run -it -p 30000:8080 amazoncorretto:11 /bin/bash`
* ![preview](images)

## now lets download the spring petclinic
* refer: https://github.com/spring-projects/spring-petclinic.git
* 
  